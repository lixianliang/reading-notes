# raft
    raft算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一直

### 角色
    领导者 leader
    跟随者 follower
    候选人 candidate

    raft算法使用随机超时150ms-300ms;降低选举冲突
    跟随者等待领导者心跳信息超时的时间间隔，是随机的
    当没有候选人赢得过半票数，选举无效了，这时需要等待一个随机时间间隔，也就是说，等待选举超时的时间间隔，是随机的

    任期

### 选举规则
1. 领导者周期性地向所有跟随者发送心跳消息（即不包含日志项的日志复制 RPC 消息），通知大家我是领导者，阻止跟随者发起新的选举
    同时应用日志异步提交
1. 如果在指定时间内，跟随者没有接收到来自领导者的消息，那么它就认为当前没有领导者，推举自己为候选人，发起领导者选举
1. 在一次选举中，赢得大多数选票的候选人，将晋升为领导者
1. 在一个任期内，领导者一直都会是领导者，直到它自身出现问题（比如宕机），或者因为网络延迟，其他节点发起一轮新的选举
1. 在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，并且按照“先来先服务”的原则进行投票。比如节点 C 的任期编号为 3，先收到了 1 个包含任期编号为 4 的投票请求（来自节点 A），然后又收到了 1 个包含任期编号为 4 的投票请求（来自节点 B）。那么节点 C 将会把唯一一张选票投给节点 A，当再收到节点 B 的投票请求RPC 消息时，对于编号为 4 的任期，已没有选票可投了
    每一任期投一次，先来先得
### 小结
    raft和multi-paxos不同的两点
    1. raft不是所有节点都能当领导者只有日志最完整的节点才能当选领导者；其次raft日志必须是连续的

## Raft算法（二）：如何复制日志

### 日志理解
1. 用户数据 command
1. 索引值 log index
1. 任期编号 term

1. 跟随者的日志应用提交时异步提交（通过心跳消息）
    怎么避免无效log和选举

### 写入过程
1. 接收到客户端请求后，领导者基于客户端请求中的指令，创建一个新日志项，并附加到本地日志中
1. 领导者通过日志复制 RPC，将新的日志项复制到其他的服务器
1. 当领导者将日志项，成功复制到大多数的服务器上的时候，领导者会将这条日志项提交到它的状态机中
1. 领导者将执行的结果返回给客户端
1. 当跟随者接收到心跳信息，或者新的日志复制 RPC 消息后，如果跟随者发现领导者已经提交了某条日志项，而它还没提交，那么跟随者就将这条日志项提交到本地的状态机中

### 如何实现日志一致
    领导者通过日志复制rpc的一致性检查

1. PrevLogEntry
    要复制日志项前面一条日志项的索引值
1. PrevLogTerm
    要复制日志项前面一条日志项的任期编号

    若follower一致则成功，否则返回faile；继续上一个prevlogentry；直到找到一致的log，follwer会出现log覆盖，leader不会有日志覆盖只有追加

    追随者使用uncommited的log进行选举，就是没应用的日志

## Raft算法（三）：如何解决成员变更的问题
    每次增加和减少单个节点，保证大多数执行一个节点存在
    不管旧的集群配置是怎么组成的，旧配置的“大多数”和新配置的“大多数”都会有一个节点是重叠的
    
    也就是说，不会同时存在旧配置和新配置 2个“大多数
