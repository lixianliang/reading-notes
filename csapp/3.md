# 第三章 程序的机器表示

## 机器级代码
1. 汇编代码

    汇编代码表示接近机器代码，与二进制的目标代码相比汇编代码更具有可读性

``` shell
gcc -S code.c 可以生成汇编代码
gcc -o code.c 可以生成二进制代码
objdump -d code.o 可以将二进制代码翻译成汇编代码
```

1. 汇编代码是怎么映射到二进制机器代码的
    IA32指令定义了汇编代码和机器代码的映射关系，IA32的指令长度在1-15个字节范围内，指令设计常用指令字节数少，不常用字节数多

## 数据格式
1. 数据的传送指令

    movb:传送字节 <br>
    movw:传送字 <br>
    movl:传送双字 <br>
    
## 访问信息
1. IA32 8个32位寄存器

    %esp：栈指针，指向堆栈段

    %ebp：帧指针（基地址指针）

    %eip: 存储一条要执行的指令的偏移地址
    
    %eax: 累加寄存器，可以用于乘、除

    %ecx: 计数寄存器，在循环和字符串操作时，控制循环次数

    %edx: 数据寄存器，用于输入/输出操作，还于AX寄存器用于涉及大值的乘法和除法运算

    %ebx: 用于索引地址

    %esi: 用于字符串操作源的索引

    %edi: 用作字符串操作的目标索引

## 调用过程
1. CALL
    CALL指令调用另外一个函数，通过RET指令将控制返回给调用过程,PUSH和POP进行堆栈操作，堆栈是朝着低地址方向增长，因为栈是从上往下的

1. 局部变量内存的管理
    数据的传递、局部变量的分配释放都是通过操作程序栈来实现的

## 数组分配和访问
1. 数组
    数组是一组连续的内存地址；在机器级代码中数组访问为数组基地址+索引乘以数据类型大小，例如`movl （%edx, %ecx, 4), %eax`
    
    edx: 数组的地址存在edx中， ecx存储索引

    leal指令来产生地址，可以理解c中取地址操作；movl用来引用存储器

1. 多维数组
    多维数组也是一个连续的内存地址，`Arr[M][N]`可以看成M行N列的数组，第二行的数据的地址紧接着第一行的地址；对应到汇编代码多维数组的访问就是对应的地址运算

## 结构体和联合
1. c的结构体
    结构体的成员字段访问：结构体的偏移量计算
    
1. c联合
    多个字段共用同一存储块，一般会配合一个引用类型的标记字段

## 对齐


## 理解指针
1. 指针的理解
    每个指针都有一个类型，并且都有一个值

    指针使用&运算符创建的，`*`  操作符用于指针的间接引用，其结果是一个值

    数组和指针是有联系的，可以引用一个数组的名字当作一个指针

    指针可以指向函数

## 汇编gdb
1. 汇编gdb常用指令
    quit run  kill break stepi disas disas sum 
    
    print /x $eax 

    info registers 

    info frame 

## 存储器的越界和缓冲区溢出
    c没有数组越界检查能力，一个数组的写越界很容易破坏存储在栈中的信息

    缓冲区的溢出也是病毒和蠕虫的入侵系统的常用方式
