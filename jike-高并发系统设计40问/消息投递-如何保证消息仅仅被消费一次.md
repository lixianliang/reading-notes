
## 休息丢失场景

1. 消息从生成者写入到消息队列的过程
    因网络抖动，需要进行消息重传，可能会出现重复消息
    
1. 消息在消息队列存储
   写入到page cache，减少磁盘的随机IO，进行异步刷盘 
   不建议通过同步的方式强制刷盘，性能会很低；可通过集群的方式部署kafka，通过多个副本保证消息不丢失
    默认kafka是通过异步复制数据给follwer，可通过ISR配置；同步多少follower消息确认被发送成功
    
1. 消息被消费者消费的过程
    一定要等到消息接收和处理完成后才能更新消费进度，但是这也会造成消息重复的问题

## 如何保证消息只被消费一次
   保证消息处理是幂等操作，多次执行和执行一次结果是一样 

1. 消息生成
    在kafka0.11 pulsar都支持生成的幂等性，在给每个生产者一个唯一id，并且为生成的每一条消息赋予一个唯一id，消息队列服务端会存储生产者id和最后一条消息的id的映射
    进行消息比对，识别重复消息

1. 消费端保证等需要通用层和业务层两个方面来考虑
    在消息生产时可通过一个发号器生成一个全局唯一的消息id
    消息被处理之后把这个id存储在数据库中，在处理消息先从数据库查询这个全局id是否被消费过，如果被消费就放弃消息

    无论是生产端的幂等性保证方式，还是消费端通用的幂等性保证方式都是生成一个全局唯一的id，然后对比id来进行去重

1. 还有一个问题，消息处理之后还没来得及写数据库(指的是消费的全局id)，消费者宕机
    1. 引入分布式事务，保证两者为原子性
    1. 通过乐观锁来实现
        在生产消息时，产生一个版本；连同消息发送给消息队列；消费者拿到消息和版本号后，在执行sql带上版本号
        保证只进行一次update操作
``` sql
update user set amount = amount + 20, version=version+1 where userid=1 and version=xxx
```
    
